function [methodinfo,structs,enuminfo,ThunkLibName]=usbdrdaqMFile
%USBDRDAQMFILE Create structures to define interfaces found in 'usbDrDaqApi'.

%This function was generated by loadlibrary.m parser version  on Mon Dec  5 15:37:37 2016
%perl options:'usbDrDaqApi.i -outfile=usbdrdaqMFile.m'
ival={cell(1,0)}; % change 0 to the actual number of functions to preallocate the data.
structs=[];enuminfo=[];fcnNum=1;
fcns=struct('name',ival,'calltype',ival,'LHS',ival,'RHS',ival,'alias',ival);
ThunkLibName=[];
% PICO_STATUS _stdcall UsbDrDaqOpenUnit ( int16_t * handle ); 
fcns.name{fcnNum}='UsbDrDaqOpenUnit'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS _stdcall UsbDrDaqCloseUnit ( int16_t handle ); 
fcns.name{fcnNum}='UsbDrDaqCloseUnit'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16'};fcnNum=fcnNum+1;
% PICO_STATUS _stdcall UsbDrDaqGetUnitInfo ( int16_t handle , char * string , int16_t stringLength , int16_t * requiredSize , PICO_INFO info ); 
fcns.name{fcnNum}='UsbDrDaqGetUnitInfo'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'cstring', 'int16', 'int16Ptr', 'uint32'};fcnNum=fcnNum+1;
% PICO_STATUS _stdcall UsbDrDaqRun ( int16_t handle , uint32_t no_of_values , BLOCK_METHOD method ); 
fcns.name{fcnNum}='UsbDrDaqRun'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32', 'e_BLOCK_METHOD'};fcnNum=fcnNum+1;
% PICO_STATUS _stdcall UsbDrDaqReady ( int16_t handle , int16_t * ready ); 
fcns.name{fcnNum}='UsbDrDaqReady'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS _stdcall UsbDrDaqStop ( int16_t handle ); 
fcns.name{fcnNum}='UsbDrDaqStop'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16'};fcnNum=fcnNum+1;
% PICO_STATUS _stdcall UsbDrDaqSetInterval ( int16_t handle , uint32_t * us_for_block , uint32_t ideal_no_of_samples , uint32_t * channels , int16_t no_of_channels ); 
fcns.name{fcnNum}='UsbDrDaqSetInterval'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32Ptr', 'uint32', 'uint32Ptr', 'int16'};fcnNum=fcnNum+1;
% PICO_STATUS _stdcall UsbDrDaqSetIntervalF ( int16_t handle , float * us_for_block , uint32_t ideal_no_of_samples , uint32_t * channels , int16_t no_of_channels ); 
fcns.name{fcnNum}='UsbDrDaqSetIntervalF'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'singlePtr', 'uint32', 'uint32Ptr', 'int16'};fcnNum=fcnNum+1;
% PICO_STATUS _stdcall UsbDrDaqSetTrigger ( int16_t handle , uint16_t enabled , uint16_t auto_trigger , uint16_t auto_ms , uint16_t channel , uint16_t dir , int16_t threshold , uint16_t hysterisis , float delay ); 
fcns.name{fcnNum}='UsbDrDaqSetTrigger'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint16', 'uint16', 'uint16', 'uint16', 'uint16', 'int16', 'uint16', 'single'};fcnNum=fcnNum+1;
% PICO_STATUS _stdcall UsbDrDaqGetValues ( int16_t handle , int16_t * values , uint32_t * noOfValues , uint16_t * overflow , uint32_t * triggerIndex ); 
fcns.name{fcnNum}='UsbDrDaqGetValues'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int16Ptr', 'uint32Ptr', 'uint16Ptr', 'uint32Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS _stdcall UsbDrDaqGetValuesF ( int16_t handle , float * values , uint32_t * noOfValues , uint16_t * overflow , uint32_t * triggerIndex ); 
fcns.name{fcnNum}='UsbDrDaqGetValuesF'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'singlePtr', 'uint32Ptr', 'uint16Ptr', 'uint32Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS _stdcall UsbDrDaqGetTriggerTimeOffsetNs ( int16_t handle , int64_t * time ); 
fcns.name{fcnNum}='UsbDrDaqGetTriggerTimeOffsetNs'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int64Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS _stdcall UsbDrDaqGetSingle ( int16_t handle , USB_DRDAQ_INPUTS channel , int16_t * value , uint16_t * overflow ); 
fcns.name{fcnNum}='UsbDrDaqGetSingle'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'enUsbDrDaqInputs', 'int16Ptr', 'uint16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS _stdcall UsbDrDaqGetSingleF ( int16_t handle , USB_DRDAQ_INPUTS channel , float * value , uint16_t * overflow ); 
fcns.name{fcnNum}='UsbDrDaqGetSingleF'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'enUsbDrDaqInputs', 'singlePtr', 'uint16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS _stdcall UsbDrDaqOpenUnitAsync ( int16_t * status ); 
fcns.name{fcnNum}='UsbDrDaqOpenUnitAsync'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS _stdcall UsbDrDaqOpenUnitProgress ( int16_t * handle , int16_t * progress , int16_t * complete ); 
fcns.name{fcnNum}='UsbDrDaqOpenUnitProgress'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16Ptr', 'int16Ptr', 'int16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS _stdcall UsbDrDaqGetScalings ( int16_t handle , USB_DRDAQ_INPUTS channel , int16_t * nScales , int16_t * currentScale , char * names , int16_t namesSize ); 
fcns.name{fcnNum}='UsbDrDaqGetScalings'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'enUsbDrDaqInputs', 'int16Ptr', 'int16Ptr', 'cstring', 'int16'};fcnNum=fcnNum+1;
% PICO_STATUS _stdcall UsbDrDaqSetScalings ( int16_t handle , USB_DRDAQ_INPUTS channel , int16_t scalingNumber ); 
fcns.name{fcnNum}='UsbDrDaqSetScalings'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'enUsbDrDaqInputs', 'int16'};fcnNum=fcnNum+1;
% PICO_STATUS _stdcall UsbDrDaqSetSigGenBuiltIn ( int16_t handle , int32_t offsetVoltage , uint32_t pkToPk , int16_t frequency , USB_DRDAQ_WAVE waveType ); 
fcns.name{fcnNum}='UsbDrDaqSetSigGenBuiltIn'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int32', 'uint32', 'int16', 'enUsbDrDaqWave'};fcnNum=fcnNum+1;
% PICO_STATUS _stdcall UsbDrDaqSetSigGenArbitrary ( int16_t handle , int32_t offsetVoltage , uint32_t pkToPk , int16_t * arbitraryWaveform , int16_t arbitraryWaveformSize , int32_t updateRate ); 
fcns.name{fcnNum}='UsbDrDaqSetSigGenArbitrary'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int32', 'uint32', 'int16Ptr', 'int16', 'int32'};fcnNum=fcnNum+1;
% PICO_STATUS _stdcall UsbDrDaqStopSigGen ( int16_t handle ); 
fcns.name{fcnNum}='UsbDrDaqStopSigGen'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16'};fcnNum=fcnNum+1;
% PICO_STATUS _stdcall UsbDrDaqSetDO ( int16_t handle , USB_DRDAQ_GPIO IOChannel , int16_t value ); 
fcns.name{fcnNum}='UsbDrDaqSetDO'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'enUsbDrDaqDO', 'int16'};fcnNum=fcnNum+1;
% PICO_STATUS _stdcall UsbDrDaqSetPWM ( int16_t handle , USB_DRDAQ_GPIO IOChannel , uint16_t period , uint8_t cycle ); 
fcns.name{fcnNum}='UsbDrDaqSetPWM'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'enUsbDrDaqDO', 'uint16', 'uint8'};fcnNum=fcnNum+1;
% PICO_STATUS _stdcall UsbDrDaqGetInput ( int16_t handle , USB_DRDAQ_GPIO IOChannel , int16_t pullUp , int16_t * value ); 
fcns.name{fcnNum}='UsbDrDaqGetInput'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'enUsbDrDaqDO', 'int16', 'int16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS _stdcall UsbDrDaqStartPulseCount ( int16_t handle , USB_DRDAQ_GPIO IOChannel , int16_t direction ); 
fcns.name{fcnNum}='UsbDrDaqStartPulseCount'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'enUsbDrDaqDO', 'int16'};fcnNum=fcnNum+1;
% PICO_STATUS _stdcall UsbDrDaqGetPulseCount ( int16_t handle , USB_DRDAQ_GPIO IOChannel , int16_t * count ); 
fcns.name{fcnNum}='UsbDrDaqGetPulseCount'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'enUsbDrDaqDO', 'int16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS _stdcall UsbDrDaqEnableRGBLED ( int16_t handle , int16_t enabled ); 
fcns.name{fcnNum}='UsbDrDaqEnableRGBLED'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int16'};fcnNum=fcnNum+1;
% PICO_STATUS _stdcall UsbDrDaqSetRGBLED ( int16_t handle , uint16_t red , uint16_t green , uint16_t blue ); 
fcns.name{fcnNum}='UsbDrDaqSetRGBLED'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint16', 'uint16', 'uint16'};fcnNum=fcnNum+1;
% PICO_STATUS _stdcall UsbDrDaqGetChannelInfo ( int16_t handle , float * min , float * max , int16_t * places , int16_t * divider , USB_DRDAQ_INPUTS channel ); 
fcns.name{fcnNum}='UsbDrDaqGetChannelInfo'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'singlePtr', 'singlePtr', 'int16Ptr', 'int16Ptr', 'enUsbDrDaqInputs'};fcnNum=fcnNum+1;
% PICO_STATUS  _stdcall UsbDrDaqPingUnit ( int16_t handle ); 
fcns.name{fcnNum}='UsbDrDaqPingUnit'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16'};fcnNum=fcnNum+1;
enuminfo.enUsbDrDaqWave=struct('USB_DRDAQ_SINE',0,'USB_DRDAQ_SQUARE',1,'USB_DRDAQ_TRIANGLE',2,'USB_DRDAQ_RAMP_UP',3,'USB_DRDAQ_RAMP_DOWN',4,'USB_DRDAQ_DC',5);
enuminfo.enUsbDrDaqInputs=struct('USB_DRDAQ_CHANNEL_EXT1',1,'USB_DRDAQ_CHANNEL_EXT2',2,'USB_DRDAQ_CHANNEL_EXT3',3,'USB_DRDAQ_CHANNEL_SCOPE',4,'USB_DRDAQ_CHANNEL_PH',5,'USB_DRDAQ_CHANNEL_RES',6,'USB_DRDAQ_CHANNEL_LIGHT',7,'USB_DRDAQ_CHANNEL_TEMP',8,'USB_DRDAQ_CHANNEL_MIC_WAVE',9,'USB_DRDAQ_CHANNEL_MIC_LEVEL',10,'USB_DRDAQ_MAX_CHANNELS',10);
enuminfo.enUSBDrDAQInfo=struct('USBDrDAQ_DRIVER_VERSION',0,'USBDrDAQ_USB_VERSION',1,'USBDrDAQ_HARDWARE_VERSION',2,'USBDrDAQ_VARIANT_INFO',3,'USBDrDAQ_BATCH_AND_SERIAL',4,'USBDrDAQ_CAL_DATE',5,'USBDrDAQ_KERNEL_DRIVER_VERSION',6,'USBDrDAQ_ERROR',7,'USBDrDAQ_SETTINGS',8,'USBDrDAQ_FIRMWARE_VERSION',9);
enuminfo.e_BLOCK_METHOD=struct('BM_SINGLE',0,'BM_WINDOW',1,'BM_STREAM',2);
enuminfo.enUsbDrDaqDO=struct('USB_DRDAQ_GPIO_1',1,'USB_DRDAQ_GPIO_2',2,'USB_DRDAQ_GPIO_3',3,'USB_DRDAQ_GPIO_4',4);
enuminfo.enUsbDrDaqScopeRange=struct('USB_DRDAQ_1V25',0,'USB_DRDAQ_2V5',1,'USB_DRDAQ_5V',2,'USB_DRDAQ_10V',3);
methodinfo=fcns;